# C语言初级考试总结

赋值操作符的优先级比较低

```C
int i=10;
int j=20;
int k=3;
k *=i+j;   (k=90)
```

局部变量只能在局部函数范围内使用，局部变量和全局变量名字冲突的情况下，局部优先。

```c
int a=1;
void test(){
    int a=2;
    a +=1;
}
int main(){
    test();
    printf("%d\n",a);
    return 0;
}
```

C语言规定，main函数的位置为任意的

一个c源程序必须包含一个main函数

C语言本身没有输入输出语句，这些库函数独立于C语言之外。

*p++ -> =  *p; p=p+1;  先用*p;然后再加加；

![](C:\Users\刘倩\AppData\Roaming\Typora\typora-user-images\image-20231202120851753.png)

```c
#include <stdio.h>
int main()
{
    int i = 0,a=0,b=2,c =3,d=4;
    i = a++ && ++b && d++;
    //i = a++||++b||d++;
    printf("a = %d\n b = %d\n c = %d\nd = %d\n", a, b, c, d);
    return 0;
}
//程序输出的结果
```

&& 左边为假，右边不计算

|| 左边为真，右边不计算

**位操作符**

& - 按（二进制）位于

| -按（二进制）位或

^  -按（二进制）位异或

![image-20231202141448443](C:\Users\刘倩\AppData\Roaming\Typora\typora-user-images\image-20231202141448443.png)

![image-20231202141936499](C:\Users\刘倩\AppData\Roaming\Typora\typora-user-images\image-20231202141936499.png)

反码、原码和补码是在计算机中表示有符号整数的三种不同方式。

1. **原码（Sign-Magnitude）:**
   - 最高位是符号位（0表示正数，1表示负数），其余位表示数值的绝对值。
   - 例如，+5 的原码是 `00000101`，-5 的原码是 `10000101`。

2. **反码（Ones' Complement）:**
   - 正数的反码与原码相同。
   - 负数的反码是将其原码中除了符号位以外的每一位取反。
   - 例如，+5 的反码是 `00000101`，-5 的反码是 `11111010`。

3. **补码（Two's Complement）:**
   - 正数的补码与原码相同。
   - 负数的补码是将其反码加1。
   - 补码是计算机中表示有符号整数的标准方式，因为它在加法和减法运算中更方便。
   - 例如，+5 的补码是 `00000101`，-5 的补码是 `11111011`。

在补码表示中，有一个额外的好处是，0的表示是唯一的，而且加法和减法可以在不需要特殊处理符号位的情况下进行。这使得补码更加适合计算机进行算术运算。

需要注意的是，上述描述是针对8位整数的示例，实际中可能使用不同位数的整数。不同位数会影响表示范围和溢出的处理方式。

假设我们使用8位二进制表示整数。以下是一些负数的原码、反码和补码：

1. **-3 的原码、反码和补码：**
   - 原码：`10000011`
   - 反码：`11111100`
   - 补码：`11111101`

2. **-6 的原码、反码和补码：**
   - 原码：`10000110`
   - 反码：`11111001`
   - 补码：`11111010`

3. **-9 的原码、反码和补码：**
   - 原码：`10001001`
   - 反码：`11110110`
   - 补码：`11110111`

这里，最高位是符号位，0 表示正数，1 表示负数。对于负数的反码和补码，是将原码中除符号位外的每一位取反，再在反码的基础上加1。这样的处理方式使得负数的表示更适合计算机进行加法和减法运算。

"**8421"** 是指二进制-十进制编码中的一种权重分配方式，其中每个二进制位的权重是 8、4、2、1。

在这种编码方式下，一个四位的二进制数可以表示 0 到 15 的十进制数。每个二进制位上的值乘以对应的权重，然后将结果相加，即可得到十进制表示。

例如：

- 二进制数 `1011` 在 "8421" 编码中的值为：\(1 \ 8 + 0 \4 + 1\2 + 1 \1 = 8 + 0 + 2 + 1 = 11\)。

- 二进制数 `1100` 在 "8421" 编码中的值为：\(1 \8 + 1 \4 + 0 \2 + 0 \1 = 8 + 4 + 0 + 0 = 12\)。

这种编码方式主要用于七段数码管和BCD（Binary-Coded Decimal）等应用。在BCD中，每个十进制数字使用4位的二进制数表示，分别对应其十进制表示的个位和十位。

将**十进制数转换为二进制数**的方法是使用二进制的除 2 取余法。以下是将一个十进制数转换为二进制数的步骤：

1. **除以2取余：** 从给定的十进制数开始，将其除以2，记录余数。余数是当前二进制位的值。

2. **商作为新的被除数：** 将商作为新的被除数，重复步骤1，直到商为0为止。

3. **读取余数：** 从下往上读取所有的余数，得到的就是十进制数的二进制表示。

让我们以一个例子来说明：

**将十进制数 13 转换为二进制数：**

1. 13 除以 2 得商 6，余数 1（最低位）。
2. 6 除以 2 得商 3，余数 0。
3. 3 除以 2 得商 1，余数 1。
4. 1 除以 2 得商 0，余数 1（最高位）。

将余数从下往上读取，得到的二进制表示为 `1101`。

所以，十进制数 13 转换为二进制数为 `1101`。